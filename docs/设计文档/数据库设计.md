# 实验室多端Web库存管理系统 - 数据库设计

## 1. 数据库概述

### 1.1 数据库选型

- **数据库类型**：SQLite
- **选择理由**：
  - 轻量级，无需独立服务器
  - 易于部署和维护
  - 支持标准SQL语法
  - 适合小型应用和原型开发
  - 内置事务支持
  - 跨平台兼容性好
  - 性能足够满足当前需求

### 1.2 设计原则

1. **数据完整性**：确保数据的准确性和一致性
2. **规范化设计**：遵循数据库规范化原则，减少数据冗余
3. **可扩展性**：支持未来功能扩展
4. **性能优化**：考虑查询性能，合理设计索引
5. **安全性**：保护敏感数据，实现数据加密
6. **易用性**：便于开发和维护

## 2. 数据库表结构设计

### 2.1 表结构概览

| 表名 | 主要功能 | 关联表 |
|------|----------|--------|
| users | 用户信息管理 | operation_logs, inventory_data |
| table_structures | 表格结构管理 | inventory_data |
| inventory_data | 库存数据管理 | operation_logs |
| operation_logs | 操作日志管理 | users, table_structures, inventory_data |

### 2.2 详细表结构

#### 2.2.1 用户表（users）

**表名**：users
**描述**：存储系统用户信息

| 字段名 | 数据类型 | 长度 | 约束 | 描述 |
|--------|----------|------|------|------|
| id | INTEGER | - | PRIMARY KEY, AUTOINCREMENT | 用户ID，主键 |
| username | VARCHAR | 50 | UNIQUE, NOT NULL | 用户名，唯一标识 |
| password | VARCHAR | 255 | NOT NULL | 密码，使用bcrypt加密存储 |
| role | VARCHAR | 20 | NOT NULL | 用户角色：admin（管理员）、leader（组长）、member（组员） |
| created_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间 |

**索引设计**：
- 唯一索引：username（提高登录验证速度）

**数据示例**：
```json
{
  "id": 1,
  "username": "admin",
  "password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
  "role": "admin",
  "created_at": "2025-12-06 10:00:00",
  "updated_at": "2025-12-06 10:00:00"
}
```

#### 2.2.2 表格结构表（table_structures）

**表名**：table_structures
**描述**：存储自定义表格的结构信息

| 字段名 | 数据类型 | 长度 | 约束 | 描述 |
|--------|----------|------|------|------|
| id | INTEGER | - | PRIMARY KEY, AUTOINCREMENT | 表格结构ID，主键 |
| table_name | VARCHAR | 255 | NOT NULL | 总表名，用于标识不同类型的库存数据 |
| columns | TEXT | - | NOT NULL | 列定义JSON字符串，格式：[{"column_name": "列名", "data_type": "数据类型"}...] |
| created_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间 |

**索引设计**：
- 索引：table_name（提高表格查询速度）

**数据示例**：
```json
{
  "id": 1,
  "table_name": "引物库存表",
  "columns": "[{\"column_name\": \"时间\", \"data_type\": \"string\"}, {\"column_name\": \"姓名\", \"data_type\": \"string\"}, {\"column_name\": \"引物名称\", \"data_type\": \"string\"}, {\"column_name\": \"数量\", \"data_type\": \"string\"}, {\"column_name\": \"位置\", \"data_type\": \"string\"}]",
  "created_at": "2025-12-06 10:30:00",
  "updated_at": "2025-12-06 10:30:00"
}
```

#### 2.2.3 库存数据表（inventory_data）

**表名**：inventory_data
**描述**：存储不同表格的库存数据

| 字段名 | 数据类型 | 长度 | 约束 | 描述 |
|--------|----------|------|------|------|
| id | INTEGER | - | PRIMARY KEY, AUTOINCREMENT | 数据ID，主键 |
| table_id | INTEGER | - | FOREIGN KEY REFERENCES table_structures(id), NOT NULL | 所属表格ID，外键关联table_structures表 |
| data | TEXT | - | NOT NULL | 库存数据JSON字符串，格式：{"列名1": "值1", "列名2": "值2", ...} |
| created_by | INTEGER | - | FOREIGN KEY REFERENCES users(id), NOT NULL | 创建者ID，外键关联users表 |
| created_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间 |

**索引设计**：
- 索引：table_id（提高按表格查询数据的速度）
- 索引：created_by（提高按创建者查询数据的速度）
- 索引：created_at（提高按时间查询数据的速度）

**数据示例**：
```json
{
  "id": 1,
  "table_id": 1,
  "data": "{\"时间\": \"2025-12-06\", \"姓名\": \"张三\", \"引物名称\": \"Primer A\", \"数量\": \"100\", \"位置\": \"冰箱A-1\"}",
  "created_by": 1,
  "created_at": "2025-12-06 11:00:00",
  "updated_at": "2025-12-06 11:00:00"
}
```

#### 2.2.4 操作日志表（operation_logs）

**表名**：operation_logs
**描述**：记录用户的操作日志，用于审计和追溯

| 字段名 | 数据类型 | 长度 | 约束 | 描述 |
|--------|----------|------|------|------|
| id | INTEGER | - | PRIMARY KEY, AUTOINCREMENT | 日志ID，主键 |
| user_id | INTEGER | - | FOREIGN KEY REFERENCES users(id), NOT NULL | 操作用户ID，外键关联users表 |
| operation | VARCHAR | 255 | NOT NULL | 操作描述，如"创建表格结构"、"添加数据"等 |
| table_id | INTEGER | - | NULL | 涉及的表格ID，外键关联table_structures表 |
| data_id | INTEGER | - | NULL | 涉及的数据ID，外键关联inventory_data表 |
| created_at | DATETIME | - | DEFAULT CURRENT_TIMESTAMP | 操作时间 |

**索引设计**：
- 索引：user_id（提高按用户查询日志的速度）
- 索引：table_id（提高按表格查询日志的速度）
- 索引：created_at（提高按时间查询日志的速度）

**数据示例**：
```json
{
  "id": 1,
  "user_id": 1,
  "operation": "创建表格结构：引物库存表",
  "table_id": 1,
  "data_id": null,
  "created_at": "2025-12-06 10:30:00"
}
```

## 3. 数据库关系设计

### 3.1 实体关系图（ER图）

```
┌─────────────┐       ┌─────────────────┐       ┌─────────────────┐
│   Users     │       │ TableStructures │       │ InventoryData   │
├─────────────┤       ├─────────────────┤       ├─────────────────┤
│ id (PK)     │<──────┤ id (PK)         │<──────┤ id (PK)         │
│ username    │       │ table_name      │       │ table_id (FK)   │
│ password    │       │ columns         │       │ data            │
│ role        │       │ created_at      │       │ created_by (FK) │
│ created_at  │       │ updated_at      │       │ created_at      │
│ updated_at  │       └─────────────────┘       │ updated_at      │
└─────────────┘                                 └─────────────────┘
        │                                               ▲
        │                                               │
        ▼                                               │
┌───────────────┐                                       │
│ OperationLogs │───────────────────────────────────────┘
├───────────────┤
│ id (PK)       │
│ user_id (FK)  │
│ operation     │
│ table_id (FK) │
│ data_id (FK)  │
│ created_at    │
└───────────────┘
```

### 3.2 关系说明

1. **用户与操作日志的关系**：
   - 一个用户可以执行多个操作，生成多条操作日志
   - 一条操作日志只能属于一个用户
   - 关系类型：一对多（Users:OperationLogs = 1:N）
   - 外键：operation_logs.user_id → users.id

2. **表格结构与库存数据的关系**：
   - 一个表格结构可以包含多条库存数据
   - 一条库存数据只能属于一个表格结构
   - 关系类型：一对多（TableStructures:InventoryData = 1:N）
   - 外键：inventory_data.table_id → table_structures.id

3. **用户与库存数据的关系**：
   - 一个用户可以创建多条库存数据
   - 一条库存数据只能由一个用户创建
   - 关系类型：一对多（Users:InventoryData = 1:N）
   - 外键：inventory_data.created_by → users.id

4. **操作日志与表格结构/库存数据的关系**：
   - 一条操作日志可以涉及一个表格结构或一条库存数据
   - 一个表格结构或一条库存数据可以被多条操作日志涉及
   - 关系类型：多对多（通过operation_logs表的table_id和data_id字段实现）
   - 外键：
     - operation_logs.table_id → table_structures.id
     - operation_logs.data_id → inventory_data.id

## 4. 索引设计

### 4.1 索引概述

索引是提高数据库查询性能的重要手段，通过合理设计索引可以显著提高查询速度。本设计中，我们将为经常用于查询条件的字段创建索引，以优化查询性能。

### 4.2 索引设计详情

| 表名 | 索引字段 | 索引类型 | 索引名称 | 目的 |
|------|----------|----------|----------|------|
| users | username | UNIQUE | idx_users_username | 优化登录验证查询 |
| table_structures | table_name | NONUNIQUE | idx_table_structures_table_name | 优化表格查询 |
| inventory_data | table_id | NONUNIQUE | idx_inventory_data_table_id | 优化按表格查询数据 |
| inventory_data | created_by | NONUNIQUE | idx_inventory_data_created_by | 优化按创建者查询数据 |
| inventory_data | created_at | NONUNIQUE | idx_inventory_data_created_at | 优化按时间查询数据 |
| operation_logs | user_id | NONUNIQUE | idx_operation_logs_user_id | 优化按用户查询日志 |
| operation_logs | table_id | NONUNIQUE | idx_operation_logs_table_id | 优化按表格查询日志 |
| operation_logs | created_at | NONUNIQUE | idx_operation_logs_created_at | 优化按时间查询日志 |

### 4.3 索引优化建议

1. **避免过度索引**：索引会增加写操作的开销，因此只在经常用于查询的字段上创建索引
2. **考虑复合索引**：对于经常一起使用的查询条件，可以考虑创建复合索引
3. **定期维护索引**：定期重建索引，以保持索引的有效性
4. **监控索引使用情况**：通过分析查询日志，监控索引的使用情况，调整索引设计

## 5. 视图设计

### 5.1 视图概述

视图是基于表或其他视图的查询结果集，用于简化复杂查询和提高数据安全性。本设计中，我们将创建一些视图，以便于常用查询和报表生成。

### 5.2 视图设计

#### 5.2.1 库存数据详情视图（inventory_data_view）

**视图名**：inventory_data_view
**描述**：显示库存数据的详细信息，包括表格名称和创建者用户名

```sql
CREATE VIEW inventory_data_view AS
SELECT
    id,
    table_id,
    (SELECT table_name FROM table_structures WHERE id = inventory_data.table_id) AS table_name,
    data,
    created_by,
    (SELECT username FROM users WHERE id = inventory_data.created_by) AS created_by_username,
    created_at,
    updated_at
FROM inventory_data;
```

**用途**：
- 简化库存数据查询，避免频繁的表连接操作
- 便于生成库存数据报表
- 提高查询性能

#### 5.2.2 操作日志详情视图（operation_logs_view）

**视图名**：operation_logs_view
**描述**：显示操作日志的详细信息，包括用户名、表格名称和数据信息

```sql
CREATE VIEW operation_logs_view AS
SELECT
    id,
    user_id,
    (SELECT username FROM users WHERE id = operation_logs.user_id) AS username,
    operation,
    table_id,
    (SELECT table_name FROM table_structures WHERE id = operation_logs.table_id) AS table_name,
    data_id,
    created_at
FROM operation_logs;
```

**用途**：
- 简化操作日志查询，避免频繁的表连接操作
- 便于审计和追溯操作记录
- 提高查询性能

## 6. 存储过程与触发器设计

### 6.1 存储过程

#### 6.1.1 创建用户存储过程（create_user）

**存储过程名**：create_user
**描述**：创建新用户，自动加密密码

```sql
CREATE PROCEDURE create_user(IN p_username VARCHAR(50), IN p_password VARCHAR(255), IN p_role VARCHAR(20))
BEGIN
    INSERT INTO users(username, password, role)
    VALUES(p_username, p_password, p_role);
END;
```

**注意**：由于SQLite不直接支持存储过程，实际实现中将使用应用层代码实现类似功能。

### 6.2 触发器

#### 6.2.1 密码更新触发器（before_update_password）

**触发器名**：before_update_password
**描述**：在更新用户密码前自动加密

```sql
CREATE TRIGGER before_update_password
BEFORE UPDATE ON users
FOR EACH ROW
WHEN NEW.password != OLD.password
BEGIN
    -- 密码加密将在应用层实现
END;
```

**注意**：由于SQLite的触发器功能有限，密码加密将在应用层实现。

#### 6.2.2 删除表格时删除关联数据触发器（before_delete_table）

**触发器名**：before_delete_table
**描述**：在删除表格结构前，删除关联的库存数据和操作日志

```sql
CREATE TRIGGER before_delete_table
BEFORE DELETE ON table_structures
FOR EACH ROW
BEGIN
    -- 删除关联的操作日志
    DELETE FROM operation_logs WHERE table_id = OLD.id;
    -- 删除关联的库存数据
    DELETE FROM inventory_data WHERE table_id = OLD.id;
END;
```

**用途**：
- 确保数据完整性，避免孤儿数据
- 简化应用层代码，减少手动维护工作

#### 6.2.3 删除数据时删除关联日志触发器（before_delete_data）

**触发器名**：before_delete_data
**描述**：在删除库存数据前，删除关联的操作日志

```sql
CREATE TRIGGER before_delete_data
BEFORE DELETE ON inventory_data
FOR EACH ROW
BEGIN
    -- 删除关联的操作日志
    DELETE FROM operation_logs WHERE data_id = OLD.id;
END;
```

**用途**：
- 确保数据完整性，避免孤儿数据
- 简化应用层代码，减少手动维护工作

## 7. 数据迁移与初始化

### 7.1 数据库初始化

#### 7.1.1 初始化SQL脚本

```sql
-- 创建users表
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 创建table_structures表
CREATE TABLE IF NOT EXISTS table_structures (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name VARCHAR(255) NOT NULL,
    columns TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 创建inventory_data表
CREATE TABLE IF NOT EXISTS inventory_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_id INTEGER NOT NULL,
    data TEXT NOT NULL,
    created_by INTEGER NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (table_id) REFERENCES table_structures(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);

-- 创建operation_logs表
CREATE TABLE IF NOT EXISTS operation_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    operation VARCHAR(255) NOT NULL,
    table_id INTEGER,
    data_id INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (table_id) REFERENCES table_structures(id),
    FOREIGN KEY (data_id) REFERENCES inventory_data(id)
);

-- 创建索引
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users(username);
CREATE INDEX IF NOT EXISTS idx_table_structures_table_name ON table_structures(table_name);
CREATE INDEX IF NOT EXISTS idx_inventory_data_table_id ON inventory_data(table_id);
CREATE INDEX IF NOT EXISTS idx_inventory_data_created_by ON inventory_data(created_by);
CREATE INDEX IF NOT EXISTS idx_inventory_data_created_at ON inventory_data(created_at);
CREATE INDEX IF NOT EXISTS idx_operation_logs_user_id ON operation_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_operation_logs_table_id ON operation_logs(table_id);
CREATE INDEX IF NOT EXISTS idx_operation_logs_created_at ON operation_logs(created_at);

-- 创建视图
CREATE VIEW IF NOT EXISTS inventory_data_view AS
SELECT
    id,
    table_id,
    (SELECT table_name FROM table_structures WHERE id = inventory_data.table_id) AS table_name,
    data,
    created_by,
    (SELECT username FROM users WHERE id = inventory_data.created_by) AS created_by_username,
    created_at,
    updated_at
FROM inventory_data;

CREATE VIEW IF NOT EXISTS operation_logs_view AS
SELECT
    id,
    user_id,
    (SELECT username FROM users WHERE id = operation_logs.user_id) AS username,
    operation,
    table_id,
    (SELECT table_name FROM table_structures WHERE id = operation_logs.table_id) AS table_name,
    data_id,
    created_at
FROM operation_logs;

-- 创建触发器
CREATE TRIGGER IF NOT EXISTS before_delete_table
BEFORE DELETE ON table_structures
FOR EACH ROW
BEGIN
    DELETE FROM operation_logs WHERE table_id = OLD.id;
    DELETE FROM inventory_data WHERE table_id = OLD.id;
END;

CREATE TRIGGER IF NOT EXISTS before_delete_data
BEFORE DELETE ON inventory_data
FOR EACH ROW
BEGIN
    DELETE FROM operation_logs WHERE data_id = OLD.id;
END;

-- 插入初始管理员用户
INSERT OR IGNORE INTO users (username, password, role) VALUES
('admin', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'admin'); -- 密码：admin123
```

### 7.2 数据迁移策略

1. **开发环境**：
   - 直接使用初始化SQL脚本创建数据库
   - 每次开发前清空数据库，重新初始化

2. **测试环境**：
   - 使用初始化SQL脚本创建数据库
   - 导入测试数据
   - 定期备份和恢复数据库

3. **生产环境**：
   - 使用初始化SQL脚本创建数据库
   - 初始化必要的基础数据
   - 定期备份数据库文件
   - 实现增量数据迁移机制

## 7. 数据库安全设计

### 7.1 数据加密

1. **密码加密**：
   - 使用bcrypt算法加密存储用户密码
   - 加密过程在应用层实现
   - 不存储明文密码

2. **敏感数据处理**：
   - 对于敏感数据，考虑在应用层进行加密处理
   - 加密密钥安全管理
   - 定期更换加密密钥

### 7.2 访问控制

1. **数据库权限**：
   - 生产环境中，使用最小权限原则配置数据库用户
   - 限制数据库用户的操作权限

2. **应用层权限**：
   - 实现基于角色的权限控制（RBAC）
   - 对数据库操作进行权限检查
   - 记录敏感操作的日志

### 7.3 备份与恢复

1. **备份策略**：
   - 定期备份数据库文件
   - 备份文件存储在安全位置
   - 实现自动化备份机制

2. **恢复策略**：
   - 制定详细的恢复计划
   - 定期测试恢复流程
   - 确保恢复流程可靠有效

## 8. 数据库性能优化

### 8.1 查询优化

1. **合理设计索引**：
   - 在经常用于查询的字段上创建索引
   - 避免过度索引
   - 考虑复合索引的使用

2. **优化查询语句**：
   - 避免全表扫描
   - 减少不必要的列查询
   - 优化JOIN操作
   - 考虑使用视图简化复杂查询

3. **使用分页查询**：
   - 对大量数据使用分页查询
   - 限制返回结果的数量
   - 优化分页查询的性能

### 8.2 写操作优化

1. **批量操作**：
   - 对批量数据操作，使用事务批量处理
   - 减少提交次数

2. **减少锁竞争**：
   - 优化事务设计，减少锁持有时间
   - 避免长时间运行的事务

3. **异步处理**：
   - 对非实时数据操作，考虑使用异步处理
   - 提高系统的响应速度

### 8.3 存储优化

1. **数据库文件大小**：
   - 定期清理无用数据
   - 压缩数据库文件
   - 优化存储结构

2. **数据归档**：
   - 对历史数据进行归档处理
   - 减少活跃数据量
   - 提高查询性能

## 9. 数据库监控与维护

### 9.1 监控指标

1. **性能指标**：
   - 查询响应时间
   - 数据库连接数
   - 锁等待时间
   - IO操作次数

2. **资源指标**：
   - 数据库文件大小
   - 内存使用情况
   - CPU使用率

3. **安全指标**：
   - 异常访问次数
   - 敏感操作次数
   - 错误日志数量

### 9.2 维护计划

1. **定期备份**：
   - 每天进行全量备份
   - 每周进行增量备份
   - 每月进行归档备份

2. **定期优化**：
   - 每月优化数据库索引
   - 每季度重建索引
   - 每半年清理无用数据

3. **定期检查**：
   - 每周检查数据库状态
   - 每月检查数据完整性
   - 每季度进行性能测试

## 10. 总结

本数据库设计文档详细描述了实验室多端Web库存管理系统的数据库设计，包括表结构、关系设计、索引设计、视图设计、触发器设计等。设计遵循了数据库设计的最佳实践，确保了数据的完整性、一致性和安全性，同时考虑了系统的可扩展性和性能优化。

通过合理的数据库设计，可以提高系统的查询性能，简化应用层开发，确保数据的安全性和可靠性。本设计将为实验室多端Web库存管理系统提供坚实的数据基础，支持系统的正常运行和未来的功能扩展。